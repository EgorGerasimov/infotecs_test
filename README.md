# infotecs_test

## usage

1. **Сборка и запуск**
    - Для сборки проекта можно воспользоваться целью `all` в Makefile:

      ```
      make 
      ```

    - Для сборки и запуска проекта можно воспользоваться специальной целью `run` в Makefile:

      ```
      make run
      ```
2. **Процесс сборки**
    - Цель ` make run ` начнёт сборку с того, что возьмёт все .cpp файлы, преобразует их в .o фалы и поместит их в папку `obj`, далее все эти файлы соберутся в статическую библиотеку `buffer.a`, которая тоже попадёт в папку `obj`. По заданию, стандарт не должен быть ниже с++14, я использовал с++20, для более удобной работы с логами и системой фалов(std::format std::filesystem).

    - После всех этих действий из статической библиотеки и файла `main.cpp` собирается исполняемый файл который будет находиться в папке `bin`, и в самом конце происходит запус исполняемого файла.

3. **Очищение**
    - Для того чтобы очистить собранные/объектные файлы и вернуть директорию в исходное состояние можно воспользоваться целью в Makefile:

        ```
        make clean
        ```
4. **Форматирование**
    - Для того чтобы отформатировать(формат Google) файлы в директории, можно использовать цель в Makefile:

        ```
        make format_style
        ```
## run

1. **Что делать после запуска**
    - После того, как вы напишете make run, запустится программа, запросит у вас число от 0 до 9 на вход, чтобы сделать какое-то действие с буфером. 

    - Чтобы имитировать тяжёлую нагрузку и чтобы можно было отследить, что действительно в программе есть два потока я сделал так, при нажатии на 1 в буфер вставляется 100 000 интов (это занимает примерно 1-2 секунды), в это время можно дополнительно дать задачу как первому (удаление, сортировка, ещё одна вставка, и т.д) так и второму (чтение) потоку. 

    - Пока выполняется вставка этих элементов, можно вводить число 9 (оно отвечает за чтение буфера, чтение заключается в подсчёте количества элементов, в цикле происходит проход по каждому элементу буфера), тем самым можно наглядно выидеть как заполняется буфер.

    - При выходе из программы сначала выполняются все задачи из очереди, поэтому программа может завершаться не моментально после ввода числа 0 (именно она отвечает за выход).

2. **Логи**
    - Каждый раз, когда пользователь вводит новую задачу создается лог, он представляет из себя: время создания задачи, какого рада задача ошибка, предупреждение или информация, а дальше идёт сообщение задачи.

    - После выполнения очереди задач, создается лог с сообщением `Tasks completed`. Все логи хранятся в папке `log`, можно прямо во время работы программы наблюдать появление логов.

## about
1. **Как всё работает**

    - Для данной программы реализованы три основных класса, `Logger`, `TaskManager` и шаблонный класс `Buffer`.

    - В буфере основой всего является вектор, по сути `Buffer` это небольшая обёртка для вектора. В нём реализованы основные методы, которые требовались в задании. Чтобы можно было одновременно записывать(удалять, сортировать и т.д) и читать данные из буфера, в каждом методе есть мьютекс для того чтобы скопировать данные из основного вектора `data` в вектор `copy_data`.

    ---

    - `TaskManager` - при создании объекта этого класса в конструкторе создается поток, в котором ожидается получение какой-либо задачи для выполнения. При появлении задачи запускается вложенный цикл, который выполняет все задачи из очереди `tasks`. Добавление очереди происхдоит через метод `add_task`, в который отдаётся лямбда функция. Чтобы остановить бесконечный цикл, ожидающий задачу, существует метод `stop_thread`.

    - В данной программе два `TaskManager`, если поступает запрос на чтение, то он идёт в переменную TasksRead, все остальные запросы отправляются в переменную TasksChange. Само взаимодействие c пользователем происходит через main поток.

    ---

    - `Logger` - класс для создания логов. В каждой переменной класса `TaskManager` свой логгер, который пишет в свой лог файл, чтобы не было путаницы в логах и не нагружать программу лишними мьютексами.

## Contact information

### Мой GitHub: https://github.com/EgorGerasimov
### Moй TG: @Egor691